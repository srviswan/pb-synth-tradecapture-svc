# Testing Plan for pb-synth-tradecapture-svc

## Service Dependencies Identified

Based on the service design documentation, the following external dependencies have been identified:

### External Services (Integration Points)
1. **Solace PubSub+** - Message queue for async processing
   - Input queue: `trade/capture/input`
   - Output queue: `trade/capture/blotter`
   - Protocol: Protobuf messages

2. **SecurityMasterService** - Reference data service
   - Purpose: Product/Security lookup for enrichment
   - Integration: REST API or gRPC (to be determined)

3. **AccountService** - Reference data service
   - Purpose: Book/Account lookup for enrichment
   - Integration: REST API or gRPC (to be determined)

4. **Rule Management Service** - External rule service
   - Purpose: Dynamic rule updates (Economic, Non-Economic, Workflow)
   - Integration: REST API endpoints for rule CRUD operations

5. **Approval Workflow Service** - Workflow service
   - Purpose: Manual approval routing for PENDING_APPROVAL trades
   - Integration: REST API (to be determined)

6. **Redis** - Cache layer
   - Purpose: L2 cache for reference data and state
   - Usage: Partition state caching, reference data caching

7. **Database** - State repository
   - Purpose: Persistent storage for partition state, SwapBlotter history
   - Type: To be determined (PostgreSQL, MongoDB, etc.)

## Testing Strategy Overview

### Test Pyramid Structure
- **Unit Tests (70%)**: Fast, isolated, no external dependencies
- **Integration Tests (20%)**: Test with mocked/stubbed dependencies
- **End-to-End Tests (10%)**: Test with real services (test environment)

### Test Configuration Strategy
- Use Spring profiles or configuration properties to switch between real and mocked services
- Support profiles: `test`, `test-mocked`, `test-integration`, `test-real-services`

## Unit Tests (No Integration)

### 1. Service Layer Tests
**Location**: `src/test/java/com/pb/synth/tradecapture/service/`

#### TradeCaptureService Tests
- Test orchestration logic with mocked dependencies
- Test partition key extraction
- Test sequence number handling
- Test error handling and retry logic
- Test concurrent processing scenarios (mocked)
- Test idempotency and duplicate detection
- Test idempotency key handling
- Test duplicate trade rejection
- Test cached result return for duplicates

#### RulesEngine Tests
- Test economic rule evaluation
- Test non-economic rule evaluation
- Test workflow rule evaluation
- Test rule priority ordering
- Test rule caching and invalidation
- Test rule criteria matching (EQUALS, GREATER_THAN, etc.)
- Test rule actions execution

#### EnrichmentService Tests
- Test enrichment logic with mocked SecurityMasterService
- Test enrichment logic with mocked AccountService
- Test partial enrichment scenarios
- Test enrichment failure handling

#### ValidationService Tests
- Test ISIN validation
- Test book status validation
- Test credit limit validation
- Test state transition validation
- Test CDM compliance validation

#### StateManagementService Tests
- Test CDM state transition validation
- Test valid transitions: Executed → Formed → Settled
- Test invalid transitions (should reject)
- Test state persistence and retrieval
- Test optimistic locking

### 2. Data Model Tests
**Location**: `src/test/java/com/pb/synth/tradecapture/model/`

- Test TradeCaptureRequest serialization/deserialization
- Test SwapBlotter construction
- Test Contract wrapper around CDM NonTransferableProduct
- Test EconomicTerms creation
- Test PerformancePayout creation
- Test InterestPayout creation
- Test partition key generation

### 3. Protobuf Tests
**Location**: `src/test/java/com/pb/synth/tradecapture/proto/`

- Test TradeCaptureMessage serialization
- Test SwapBlotterMessage serialization
- Test protobuf to Java POJO conversion
- Test Java POJO to protobuf conversion
- Test message validation

### 4. Utility/Helper Tests
**Location**: `src/test/java/com/pb/synth/tradecapture/util/`

- Test partition key generation utility
- Test sequence number generation
- Test date/time utilities
- Test CDM mapping utilities

### 5. Controller Tests (MockMvc)
**Location**: `src/test/java/com/pb/synth/tradecapture/controller/`

- Test REST API endpoints with mocked services
- Test request validation
- Test response formatting
- Test error handling
- Test OpenAPI contract compliance

## Integration Tests (With Mocked Dependencies)

### 1. Service Integration Tests
**Location**: `src/test/java/com/pb/synth/tradecapture/integration/service/`

#### TradeCaptureService Integration Tests
- Test full processing flow with mocked external services
- Test enrichment → rules → validation → state management flow
- Test partition-aware sequencing with mocked state repository
- Test distributed locking behavior (mocked)

#### RulesEngine Integration Tests
- Test rule evaluation with real rule repository (in-memory)
- Test rule hot-reload functionality
- Test rule API integration (mocked Rule Management Service)

### 2. Repository Integration Tests
**Location**: `src/test/java/com/pb/synth/tradecapture/repository/`

#### StateRepository Tests
- Test with embedded database (H2 or Testcontainers)
- Test partition state CRUD operations
- Test optimistic locking
- Test concurrent access scenarios

#### IdempotencyService Tests
- Test idempotency key extraction (tradeId vs idempotencyKey)
- Test duplicate detection (cache and database)
- Test idempotency record creation and update
- Test cached result return for duplicates
- Test idempotency window expiration
- Test payload mismatch detection
- Test retry after failure idempotency
- Test message-level deduplication
- Test sequence number validation

#### RulesRepository Tests
- Test in-memory rule caching
- Test rule invalidation
- Test rule priority sorting

### 3. External Service Integration Tests (Mocked)
**Location**: `src/test/java/com/pb/synth/tradecapture/integration/external/`

#### SecurityMasterService Integration Tests
- Use WireMock to mock REST/gRPC calls
- Test successful security lookup
- Test security not found scenarios
- Test timeout and retry behavior
- Test circuit breaker behavior

#### AccountService Integration Tests
- Use WireMock to mock REST/gRPC calls
- Test successful account/book lookup
- Test account not found scenarios
- Test timeout and retry behavior

#### Rule Management Service Integration Tests
- Use WireMock to mock rule API endpoints
- Test rule creation/update/delete
- Test rule retrieval
- Test batch rule operations

#### Approval Workflow Service Integration Tests
- Use WireMock to mock approval workflow API
- Test approval request submission
- Test approval status retrieval

### 4. Message Queue Integration Tests (Mocked)
**Location**: `src/test/java/com/pb/synth/tradecapture/integration/messaging/`

#### Messaging System Integration Tests
- **Solace Integration Tests**:
  - Use embedded Solace or Solace test container
  - Test message consumption from input queue
  - Test message publication to output queue/topic
  - Test protobuf serialization/deserialization
  - Test partition-aware message routing
  - Test DLQ handling
  - Test multiple subscribers to same topic

- **Kafka Integration Tests** (if configured):
  - Use embedded Kafka or Testcontainers
  - Test topic-based publishing
  - Test consumer groups and multiple subscribers
  - Test partition assignment
  - Test offset management

- **RabbitMQ Integration Tests** (if configured):
  - Use embedded RabbitMQ or Testcontainers
  - Test exchange-based routing
  - Test multiple queues bound to exchange
  - Test message routing keys

#### Multi-Subscriber Publishing Tests
- Test publishing to multiple messaging systems simultaneously
- Test independent failure handling per subscriber
- Test delivery guarantees (at-least-once for queues)
- Test subscriber configuration and dynamic registration
- Test filtering criteria per subscriber

#### API-Based Publishing Tests
- **Webhook Publishing Tests**:
  - Test HTTP POST to multiple webhook URLs
  - Test retry logic with exponential backoff
  - Test timeout handling
  - Test failure isolation (one webhook failure doesn't affect others)

- **REST API Publishing Tests**:
  - Test HTTP POST to downstream service endpoints
  - Test circuit breaker pattern
  - Test rate limiting per downstream service
  - Test payload serialization (JSON format)

- **gRPC Publishing Tests** (if configured):
  - Test bidirectional streaming
  - Test multiple gRPC clients
  - Test connection pooling
  - Test protobuf payload delivery

### 5. Cache Integration Tests
**Location**: `src/test/java/com/pb/synth/tradecapture/integration/cache/`

#### Redis Integration Tests
- Use embedded Redis (embedded-redis) or Testcontainers
- Test cache read/write operations
- Test cache expiration
- Test cache invalidation
- Test partition state caching

## End-to-End Integration Tests (Real Services)

### 1. Full Flow Integration Tests
**Location**: `src/test/java/com/pb/synth/tradecapture/e2e/`

#### Trade Capture E2E Tests
- Test complete flow: API → Enrichment → Rules → Validation → State → Output
- Use real test environment services (configurable via profile)
- Test synchronous trade capture
- Test asynchronous trade capture
- Test batch trade capture
- Test manual trade entry flow

#### Queue-Based E2E Tests
- Test messaging queue consumption and processing (Solace, Kafka, etc.)
- Test end-to-end message flow with multiple subscribers
- Test partition sequencing with real queue
- Test DLQ behavior
- Test multiple subscribers receiving same SwapBlotter
- Test publishing to multiple messaging systems simultaneously

#### API-Based Publishing E2E Tests
- Test webhook delivery to multiple endpoints
- Test REST API push to downstream services
- Test gRPC streaming delivery
- Test failure handling and retry mechanisms
- Test delivery status tracking per subscriber

### 2. Performance Tests
**Location**: `src/test/java/com/pb/synth/tradecapture/performance/`

- Test throughput: 2M trades/day capacity
- Test peak load: 186 trades/sec (all regions)
- Test burst capacity: 8-10x multiplier
- Test partition parallel processing
- Test latency: P50, P95, P99 targets

## Test Infrastructure Setup

### 1. Test Configuration
**File**: `src/test/resources/application-test.yml`
- Configure mocked service endpoints
- Configure test database
- Configure test message queue
- Configure test cache

**File**: `src/test/resources/application-test-mocked.yml`
- All external services mocked (WireMock, embedded services)

**File**: `src/test/resources/application-test-integration.yml`
- Real services in test environment
- Testcontainers for databases/cache

**File**: `src/test/resources/application-test-real.yml`
- Real services configuration
- For manual E2E testing

### 2. Test Utilities
**Location**: `src/test/java/com/pb/synth/tradecapture/testutil/`

- Test data builders (TradeCaptureRequestBuilder, SwapBlotterBuilder)
- Mock service helpers
- Test fixtures and sample data
- CDM test data generators
- Protobuf test message generators

### 3. Test Containers Setup
- PostgreSQL container for database tests
- Redis container for cache tests
- Solace container for message queue tests (if available)
- WireMock server for HTTP service mocks

## Test Coverage Goals

- **Unit Tests**: 80%+ code coverage
- **Integration Tests**: Cover all external service integrations
- **E2E Tests**: Cover critical business flows
- **Performance Tests**: Validate scalability requirements

## Test Execution Strategy

### CI/CD Pipeline
1. **Unit Tests**: Run on every commit (fast feedback)
2. **Integration Tests (Mocked)**: Run on every commit
3. **Integration Tests (Real)**: Run on PR merge or nightly
4. **E2E Tests**: Run on staging deployment
5. **Performance Tests**: Run weekly or on demand

### Local Development
- Developers can switch between mocked and real services via Spring profiles
- `./mvnw test` - Run unit tests only
- `./mvnw test -Ptest-mocked` - Run with mocked services
- `./mvnw test -Ptest-integration` - Run with Testcontainers
- `./mvnw test -Ptest-real` - Run with real test environment services

## Container-Based Testing Considerations

### Docker Container Testing

The service is designed to run in Docker containers, and testing should account for containerized execution:

**Container Image Testing:**
- Build container image as part of CI/CD pipeline
- Test container image builds successfully
- Verify container starts and health checks pass
- Test container with different environment configurations
- Validate container resource limits and constraints

**Containerized Test Execution:**
- Run integration tests inside containers for consistency
- Use Docker-in-Docker (DinD) or Docker socket mounting in CI
- Test container networking and service discovery
- Verify environment variable injection and configuration
- Test container lifecycle (startup, shutdown, restart)

**Docker Compose for Testing:**
- Use Docker Compose to orchestrate test environment
- Include all dependencies (database, Redis, Solace, etc.) in compose file
- Test service integration with containerized dependencies
- Validate network connectivity between containers
- Test volume mounts and configuration file injection

**Container Health Checks:**
- Test health check endpoint responds correctly
- Verify readiness probe behavior (waits for dependencies)
- Test liveness probe behavior (detects service failures)
- Validate graceful shutdown in container environment
- Test container restart and recovery scenarios

**Container Security Testing:**
- Test container runs as non-root user
- Verify security context and capabilities
- Test network policies and isolation
- Validate secrets management in containers
- Test image scanning and vulnerability detection

**Kubernetes Testing (if applicable):**
- Test Kubernetes deployment manifests
- Verify ConfigMap and Secret integration
- Test horizontal pod autoscaling behavior
- Validate service discovery and DNS resolution
- Test pod disruption budgets and high availability
- Verify ingress/egress network policies

**Container Performance Testing:**
- Test performance with container resource limits
- Validate behavior under CPU and memory constraints
- Test container startup time and initialization
- Verify performance characteristics match non-containerized execution
- Test container networking performance

**Container Logging and Monitoring:**
- Test structured logging in container environment
- Verify log aggregation and forwarding
- Test metrics collection in containers
- Validate distributed tracing in containerized setup
- Test container monitoring and alerting

### Test Environment Containers

**Development Containers:**
- Docker Compose setup for local development
- Hot-reload support via volume mounts
- Development-friendly logging and debugging
- Local service dependencies in containers

**CI/CD Test Containers:**
- Ephemeral containers for test execution
- Isolated test environments per test run
- Automated cleanup after test completion
- Parallel test execution in separate containers

**Integration Test Containers:**
- Full stack containerized integration tests
- Testcontainers for database and cache dependencies
- Mock external services in separate containers
- Network isolation and service discovery testing

## Dependencies to Add

### Testing Dependencies (Maven)
```xml
<!-- JUnit 5 -->
<dependency>
    <groupId>org.junit.jupiter</groupId>
    <artifactId>junit-jupiter</artifactId>
    <scope>test</scope>
</dependency>

<!-- Mockito -->
<dependency>
    <groupId>org.mockito</groupId>
    <artifactId>mockito-core</artifactId>
    <scope>test</scope>
</dependency>
<dependency>
    <groupId>org.mockito</groupId>
    <artifactId>mockito-junit-jupiter</artifactId>
    <scope>test</scope>
</dependency>

<!-- WireMock for HTTP mocking -->
<dependency>
    <groupId>org.wiremock</groupId>
    <artifactId>wiremock-standalone</artifactId>
    <scope>test</scope>
</dependency>

<!-- Testcontainers -->
<dependency>
    <groupId>org.testcontainers</groupId>
    <artifactId>testcontainers</artifactId>
    <scope>test</scope>
</dependency>
<dependency>
    <groupId>org.testcontainers</groupId>
    <artifactId>postgresql</artifactId>
    <scope>test</scope>
</dependency>
<dependency>
    <groupId>org.testcontainers</groupId>
    <artifactId>junit-jupiter</artifactId>
    <scope>test</scope>
</dependency>

<!-- Embedded Redis -->
<dependency>
    <groupId>it.ozimov</groupId>
    <artifactId>embedded-redis</artifactId>
    <scope>test</scope>
</dependency>

<!-- Spring Boot Test -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-test</artifactId>
    <scope>test</scope>
</dependency>

<!-- AssertJ for fluent assertions -->
<dependency>
    <groupId>org.assertj</groupId>
    <artifactId>assertj-core</artifactId>
    <scope>test</scope>
</dependency>
```

## Implementation Phases

### Phase 1: Unit Tests Foundation
- Set up test infrastructure
- Create test utilities and builders
- Implement service layer unit tests
- Implement controller unit tests

### Phase 2: Integration Tests (Mocked)
- Set up WireMock for external services
- Implement repository integration tests
- Implement external service integration tests (mocked)
- Implement message queue integration tests (embedded)

### Phase 3: Integration Tests (Real/Containers)
- Set up Testcontainers
- Implement database integration tests
- Implement cache integration tests
- Implement full flow integration tests

### Phase 4: E2E and Performance Tests
- Implement E2E tests with real services
- Implement performance/load tests
- Set up test data management
- Document test execution procedures

## Service Dependency Matrix

| Service | Integration Type | Mocking Strategy | Test Container | Real Service Config |
|---------|-----------------|------------------|----------------|---------------------|
| Solace PubSub+ | Message Queue | Embedded Solace / Test Container | Solace TestContainer (if available) | Test environment Solace instance |
| Kafka | Message Queue | Embedded Kafka / Testcontainers | Testcontainers Kafka | Test environment Kafka cluster |
| RabbitMQ | Message Queue | Embedded RabbitMQ / Testcontainers | Testcontainers RabbitMQ | Test environment RabbitMQ instance |
| Webhook Subscribers | HTTP Callbacks | WireMock | N/A | Test webhook endpoints |
| REST API Subscribers | HTTP REST | WireMock | N/A | Test downstream service endpoints |
| gRPC Subscribers | gRPC Streaming | Mock gRPC server | N/A | Test gRPC service endpoints |
| SecurityMasterService | REST/gRPC | WireMock | N/A | Test environment endpoint |
| AccountService | REST/gRPC | WireMock | N/A | Test environment endpoint |
| Rule Management Service | REST API | WireMock | N/A | Test environment endpoint |
| Approval Workflow Service | REST API | WireMock | N/A | Test environment endpoint |
| Redis | Cache | Embedded Redis | Testcontainers Redis | Test environment Redis instance |
| Database | JDBC/JPA | H2 Embedded | Testcontainers PostgreSQL | Test environment database |

## Switching Between Mocked and Real Services

### Configuration Approach
1. **Spring Profiles**: Use `@ActiveProfiles` annotation or `spring.profiles.active` property
2. **Conditional Beans**: Use `@ConditionalOnProperty` to switch between real and mock implementations
3. **Test Configuration Classes**: Create separate `@TestConfiguration` classes for mocked services

### Example Configuration Structure
```yaml
# application-test-mocked.yml
services:
  security-master:
    url: http://localhost:${wiremock.port}
    mock: true
  account:
    url: http://localhost:${wiremock.port}
    mock: true
  rule-management:
    url: http://localhost:${wiremock.port}
    mock: true

# application-test-real.yml
services:
  security-master:
    url: ${SECURITY_MASTER_SERVICE_URL}
    mock: false
  account:
    url: ${ACCOUNT_SERVICE_URL}
    mock: false
  rule-management:
    url: ${RULE_MANAGEMENT_SERVICE_URL}
    mock: false
```

### Test Execution Commands
```bash
# Unit tests only (no external dependencies)
mvn test

# Integration tests with mocked services
mvn test -Ptest-mocked

# Integration tests with Testcontainers
mvn test -Ptest-integration

# E2E tests with real services (requires test environment)
mvn test -Ptest-real -Dspring.profiles.active=test-real
```

## Test Data Management

### Test Fixtures
- Create reusable test data builders
- Use factory pattern for generating test trades
- Maintain sample CDM data for testing
- Create test data for various scenarios:
  - Valid trades (automated and manual)
  - Invalid trades (validation failures)
  - Edge cases (boundary conditions)
  - Error scenarios (service failures)

### Test Data Isolation
- Each test should be independent
- Use `@Transactional` for database tests (rollback after test)
- Clear cache between tests
- Reset mock state between tests

## Monitoring and Reporting

### Test Metrics
- Track test execution time
- Monitor test coverage trends
- Track flaky tests
- Report test results in CI/CD

### Test Reports
- Generate JUnit test reports
- Generate code coverage reports (JaCoCo)
- Generate test execution summaries
- Integrate with CI/CD reporting tools

## Best Practices

1. **Test Naming**: Use descriptive test names following pattern `should_ExpectedBehavior_When_StateUnderTest`
2. **Test Organization**: Group related tests using `@Nested` classes
3. **Test Data**: Use builders for complex test data creation
4. **Assertions**: Use AssertJ for fluent assertions
5. **Mocking**: Mock external dependencies, not internal implementation
6. **Test Speed**: Keep unit tests fast (< 1 second each)
7. **Test Independence**: Each test should be able to run in isolation
8. **Test Documentation**: Add comments for complex test scenarios
9. **Test Maintenance**: Keep tests updated with code changes
10. **Test Coverage**: Aim for high coverage but focus on critical paths

